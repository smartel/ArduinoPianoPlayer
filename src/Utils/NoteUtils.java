package Utils;

import DataObjs.PianoProperties;

public class NoteUtils {

	
	public NoteUtils() {
	}
	
	/**
	 * Generates a numeric value that represents the key's position on the piano, as well as making it intuitively comparable to other keys on the piano.
	 * Each white note is a whole value step (1), and half values are half-steps (sharps / flats)
	 * To show how it is intuitive - this means that "C" would be 2 steps away from "E" (C to D, then D to E, or alternatively, E to D, and then D to C)
	 *
	 * There is one special case: a Rest note is treated as having a compare value of 0, as it has no octave, no note letter, and can't be sharp or flat.
	 * Since no key is struck for a rest, there is no compare value that could be generated for it. Do not attempt to call generateCompareValue for a rest.
	 * The constant compare value used for rest notes can be found in Constants.java # REST_COMP_VALUE
	 *
	 * To generate this number, 2 values are added together:
	 * 	Value 1: generated by mapping notes to their integer position within an octave, and adding or subtracting 0.5 for sharps / flats.
	 *  	C=1,D=2,...,A=7    C flat = 0.5, C sharp = 1.5 == D flat = 1.5 ...  B flat = 6.5, B sharp = well ok bad example, that'd be a C, there is no B sharp.
	 * 	Value 2: generated via (n*7), where n is the octave the key is in. Remember that octaves start at 0, so the first value, "C" of octave 0, returns 1, "D" of octave 0 returns 2, and so on.
	 * By adding values 1 and 2 together, we can compare notes on a keyboard.
	 * For example, a 2nd octave "E" generates the value: 3 + (7*2) = 17
	 *              a 1st octave "A" generates the value: 6 + (7*1) = 13
	 * If these 2 values are compared together,
	 *  it is shown that a 1st octave "A" is a lower note than a 2nd octave "E",
	 *  and it is possible to get the key distance between them with simple subtraction.
	 *		17 - 13 == absolute value of 13 - 17 = distance of 4 keys (it takes 4 moves to get from that E key to that A key, or from that A key to get to that E key)
	 * Lastly, we can technically show that a C-flat on one octave is equivalent to a B-sharp on the previous octave.
	 * 	 C-flat on octave 3 = 1(for C) - 0.5(for flat) + (3*7) = 1 - 0.5 + 21 = 21.5
	 *   B-sharp on octave 2 = 7(for B) + 0.5(for sharp) + (2*7) = 7.0 + 0.5 + 14 = 21.5 (however, B-sharp doesn't exist, so this would be promoted to a C)
	 */
	public static double generateCompareValue(String note, int octave, boolean isSharp, boolean isFlat) {

		double value = 0;
		
		// Note: there is some mild duplicated error checking in here, but within reason - NoteUtils only cares about ensuring it is creating a valid compareValue.
		// Thus, it will ensure the octave is not non-zero / non-negative for non-rest notes, much like the MusicNote's initializer should've already checked.
		// HOWEVER, it will not check if the note exists on your piano itself - its only responsibility is creating a valid compareValue, regardless of whether it exists on your piano.

		// individual note lookup
		
		if (note.equalsIgnoreCase(Constants.NOTE_C)) {
			value += Constants.C_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_D)) {
			value += Constants.D_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_E)) {
			value += Constants.E_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_F)) {
			value += Constants.F_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_G)) {
			value += Constants.G_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_A)) {
			value += Constants.A_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_B)) {
			value += Constants.B_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_REST)) {
			// We have a hardcoded value for rest notes - a compare value of 0.
			value = Constants.REST_COMP_VALUE;
		} else {
			System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - unrecognized note value passed in.\r\nnote: " + note);
			value = -1;
		}
		
		// note modifications via half-steps
		// but if the value is already 0 (a rest note) or -1 (already failed), don't bother checking and potentially overwriting the current value.
		if (isSharp && isFlat) {
			// although, if it is a rest note, we only need to warn
			if (note.equalsIgnoreCase(Constants.NOTE_REST)) {
				System.out.println("NoteUtils#generateCompareValue - warning - isSharp and isFlat both set to true, but on a rest note, so initialization will continue.\r\nConfirmation - isSharp: " + isSharp + ", isFlat: " + isFlat + ", note: " + note);
			} else {
				System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - isSharp and isFlat both set to true.\r\nConfirmation - isSharp: " + isSharp + ", isFlat: " + isFlat);
				value = -1;
			}
		} else if (isSharp && value > 0) {
			value += Constants.SHARP_CHANGE;
		} else if (isFlat && value > 0) {
			value += Constants.FLAT_CHANGE; // adding a negative to the value to reduce it
		}
		
		// octave adjustment - only needs to confirm the octave is non-zero / non-negative. it can accurately create a compareValue for an octave no matter how high it is.
		if (octave < Constants.MIN_PIANO_OCTAVE && (!note.equalsIgnoreCase(Constants.NOTE_REST))) {
			System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - invalid octave value (0 or negative).\r\noctave: " + octave);
			return -1;
		}
		// Ensure the octave is zero if it is a rest note, but if it isn't, we only need to provide a warning, and can keep initializing
		if (octave != Constants.REST_OCTAVE_VALUE && (note.equalsIgnoreCase(Constants.NOTE_REST))) {
			System.out.println("NoteUtils#generateCompareValue - warning - non-zero octave value provided for a rest note. Octave value ignored.\r\noctave: " + octave);
		}
		
		if (value > 0) {
			value += (octave * Constants.OCTAVE_LENGTH);
		}
		
		return value;
	}
	
	/**
	 * Helper method that, when given a natural note (such as C, D, E, F, G, A or B), will return its position within an octave (ie, C=1, D=2, ... A=7)
	 * This is basically the opposite of getNoteForPosition.
	 * @return integer representing the note's position within an octave. if a position can't be determined, -1 is returned instead.
	 */
	public static int getPositionForNote(String note) {
		int value = -1;
		
		if (note.equalsIgnoreCase(Constants.NOTE_C)) {
			value = (int)Constants.C_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_D)) {
			value = (int)Constants.D_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_E)) {
			value = (int)Constants.E_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_F)) {
			value = (int)Constants.F_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_G)) {
			value = (int)Constants.G_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_A)) {
			value = (int)Constants.A_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_B)) {
			value = (int)Constants.B_POS;
		} else {
			System.out.println("NoteUtils#getPositionForNote - error - invalid note value passed in, position can't be determined. note: " + note);
		}
		
		return value;
	}
	
	/**
	 * Helper method that, when given a position within an octave (such as 1 (1st note), 2 (2nd note), 3 (3rd note), ... 7 (7th note)),
	 * will return the note letter for this position (ie, 1=C, 2=D,, ... 7=A)
	 * This is basically the opposite of getPositionForNote.
	 * @return String letter representing the note letter. If a value can't be determined, an empty String will be returned.
	 */
	public static String getNoteForPosition(int position) {
		String value = "";
		
		if (position == 1) {
			value = Constants.NOTE_C;
		} else if (position == 2) {
			value = Constants.NOTE_D;
		} else if (position == 3) {
			value = Constants.NOTE_E;
		} else if (position == 4) {
			value = Constants.NOTE_F;
		} else if (position == 5) {
			value = Constants.NOTE_G;
		} else if (position == 6) {
			value = Constants.NOTE_A;
		} else if (position == 7) {
			value = Constants.NOTE_B;
		} else {
			System.out.println("NoteUtils#getNoteForPosition - error - invalid position value passed in, note letter can't be determined. position: " + position);
		}
		
		return value;
	}
	
	/**
	 * Given the compareValue for a specific note, as well as which piano voice / instrument to use,
	 * this will returns the uri of the appropriate .wav file to play the note (for use with the Feigner)
	 * 
	 * It should be noted, that the sounds played are simple .wav files, and their lengths are not extended or shortened by the note's duration,
	 * nor are they interruptable. You can kind of imagine the gui is... playing pizzicato. Quick little bursts for each note.
	 * When the arduino is in action, it will make use of the duration fields to know how long to extend a "finger" for on a note, so it will be used there.
	 * 
	 * @param compareValue the piano key to find the sound file for
	 * @param voice the instrument or "voice" (ie grand (piano), orgel, harpsichord, ...) to play the note with. See Constants.java for a list of implemented voices.
	 * @return uri of the .wav file containing that piano key's sound
	 */
	public static String getSoundWavForNote(double compareValue, String voice, PianoProperties properties) {
		String uri = "";
		boolean valid = true;
		double compMin = Double.parseDouble(properties.getSetting(Constants.SETTINGS_MIN_COMP_VALUE));
		double compMax = Double.parseDouble(properties.getSetting(Constants.SETTINGS_MAX_COMP_VALUE));
		
		if (!voice.equalsIgnoreCase(Constants.VOICE_ORGEL) && !voice.equalsIgnoreCase(Constants.VOICE_GRAND)) {
			System.out.println("NoteUrils#getSoundWavForNote - error - invalid voice supplied: " + voice);
			valid = false;
		}
		
		// compareValue range checking
		if (compareValue == Constants.REST_COMP_VALUE) {
			System.out.println("NoteUrils#getSoundWavForNote - error - invalid compare value given: " + Constants.REST_COMP_VALUE + ". Was this accidentally called for a Rest note? Confirmation - compareValue: " + compareValue);
		}
		// use piano properties to get min / max compare value for range checking.
		if ( (compareValue < compMin) ||
			 (compareValue > compMax) ) {
			System.out.println("NoteUrils#getSoundWavForNote - error - invalid compare value supplied: " + compareValue + ". Maximum range via piano properties was between: " + compMin + " and " + compMax + ".");
		}
		
		
		if (valid && voice.equalsIgnoreCase(Constants.VOICE_ORGEL)) {
			uri = "orgel/" + compareValue + ".wav";
		} else if (valid && voice.equalsIgnoreCase(Constants.VOICE_GRAND)) {
			uri = "grand/" + compareValue + ".wav";
		}
		
		return uri;
	}
	
	/**
	 * Given a compareValue, this will determine the next immediately after it, whether it is a whole note skip or just a sharp
	 * (so, it determines if 0.5 or if 1.0 needs to be added to the current compare value), and then returns it
	 * @param compareVal the compareValue of the current note, to generate the next note's value from
	 * @return the compareValue of the note immediately after the supplied note, or -1 if an invalid compareVal was supplied
	 */
	public static double getNextNoteCV(double compareVal) {
		double nextCompVal = -1;
		
		// since generating the compare value simply follows a pattern of seeing what letter note we're on and what the next letter note is,
		// we don't really need to do bounds checking on the input value other than making sure it isn't negative / 0
		if (compareVal <= Constants.REST_COMP_VALUE) {
			System.out.println("NoteUtils#getNextNoteCV - error - invalid compare value supplied to generate the next note from. Supplied compareVal: " + compareVal);
		} else {
			if (compareVal % 1 == 0.5) { // if we are on a sharp, then we know we just need to add 0.5 to get to the next note
				
				// Verify a valid compareVal was supplied, and not something like a 3.5 (an E sharp). If an invalid starting point was supplied, return -1
				if (verifyValidNonRestCompareValue(compareVal) == false) {
					nextCompVal = -1;
				} else {
					nextCompVal = compareVal + 0.5;
				}
				
			} else {
				// we know we are not on a sharp/flat, so we're on A,B,C,D,E,F,G. B and E do not have sharps.
				// narrow it down to one octave, so we solely had the "Note Position within an octave", ie, 1=A, 2=B, ..., 7=G
				int temp = (int)compareVal;
				while (temp > 7) {
					temp -= 7;
				}
				if (temp == Constants.B_POS || temp == Constants.E_POS) { // if B or E, we add one to the given compareValue and return it, since there is no sharp on these two notes
					nextCompVal = compareVal + 1;
				} else { // otherwise, it has a sharp
					nextCompVal = compareVal + 0.5;
				}
			}
		}
		
		return nextCompVal;
	}
	
	/**
	 * NOTE: Strongly based on NoteUtils#getNextNoteCV
	 * Given a compareValue, this will determine and return the compareValue immediately below the given value, regardless of whether it is a whole note skip or a sharp.
	 * (so, it determines if 0.5 or if 1.0 needs to be subtracted from the current compare value).
	 * @param compareVal the compareValue of the current note, to generate the previous note's value from
	 * @return the compareValue of the note immediately before the supplied note, or -1 if an invalid compareVal or too low compareVal was supplied
	 *         (a compareVal of 1 is treated as the lowest note possible, so any note less than or equal to 1 will return -1)
	 */
	public static double getPrevNoteCV(double compareVal) {
		double prevCompVal = -1;
		
		// ensure we have a valid compareValue to work with (larger than the theoretical minimum key)
		if (compareVal <= Constants.MIN_THEORETICAL_COMPARE_VALUE) {
			System.out.println("NoteUtils#getNextNoteCV - error - invalid compare value supplied to generate the previous note from. Value is too low. Supplied compareVal: " + compareVal);
		} else {
			if (compareVal % 1 == 0.5) { // if we are on a sharp, then we know we just need to subtract 0.5 to get to the previous note
				
				// Verify a valid compareVal was supplied, and not something like a 3.5 (an E sharp). If an invalid starting point was supplied, return -1
				if (verifyValidNonRestCompareValue(compareVal) == false) {
					prevCompVal = -1;
				} else {
					prevCompVal = compareVal - 0.5;
				}
				
			} else {
				// we know we are not on a sharp/flat, so we're on A,B,C,D,E,F,G. B and E do not have sharps.
				// narrow it down to one octave, so we solely had the "Note Position within an octave", ie, 1=A, 2=B, ..., 7=G
				int temp = (int)compareVal;
				while (temp > 7) {
					temp -= 7;
				}
				if (temp == Constants.C_POS || temp == Constants.F_POS) { // if C or F, we subtract one to the given compareValue and return it, since there is no sharp note for B or E
					prevCompVal = compareVal - 1;
				} else { // otherwise, it has a sharp
					prevCompVal = compareVal - 0.5;
				}
			}
		}
		
		return prevCompVal;
	}
	
	/**
	 * Given a compare Value to start at, and a number of shifts to take (positive = forward, negative = backward),
	 * move that many notes in that direction and return the CV landed on, if valid. 
	 * If invalid (too far past the min or max theoretical key), it will return -1 instead (although I had considered turning the cv into a rest aka 0, effectively "deleting" it)
	 * @param compareVal starting point to shift from
	 * @param numShifts the number of shifts to take (positive = forward, negative = backward)
	 * @return the compare value shifted to, or -1 if invalid / past the theoretical min / max
	 */
	public static double getShiftedCV(double compareVal, double numShifts) {
		double result = compareVal;

		if (numShifts == 0 || compareVal == 0 || verifyValidNonRestCompareValue(compareVal) == false) {
			System.out.println("NoteUtils#getShiftedCV - error - invalid base compare value or number of shifts supplied to generate the desired CV from. Values must be a valid non-zero compareVal and a non-zero number of shifts, otherwise no shifts can be applied. Supplied compareVal: " + compareVal + ", numShifts: " + numShifts);
			result = -1;
		} else if (numShifts > 0) {
			// positive number of shifts, so we move forward - up the piano
			for (int x = 0; x < numShifts; ++x) {
				result = getNextNoteCV(result);
			}
		} else if (numShifts < 0) {
			// negative number of shifts, so we move downward - down the piano
			for (int x = 0; x > numShifts; --x) {
				result = getPrevNoteCV(result);
			}
		}
		
		// verify the resulting compareVal is valid (not past theoretical max, ...)
		if (result != -1) {
			if (verifyValidNonRestCompareValue(result) == false) {
				result = -1;
			}
		}
		
		return result;
	}
	
	/**
	 * Given a compareValue, attempts to verify its validity by determining what letter note it would be and whether or not it is sharp.
	 * If it is a rest note, if it is above or below the theoretical min / max, or if it is an invalid compare value (such as a B sharp or F flat),
	 * then this will return false.
	 * Strongly based on the code in MusicNote#ctor(compareValue, duration)
	 * @param compareVal value to check for validity
	 * @return true if the compareValue is valid, false otherwise
	 */
	public static boolean verifyValidNonRestCompareValue(double compareVal) {
		boolean result = true;
		boolean isSharp = false;
		String note;
		
		if (compareVal == Constants.REST_COMP_VALUE) {
			result = false;
		} else if (compareVal < Constants.MIN_THEORETICAL_COMPARE_VALUE) {
			result = false;
		} else if (compareVal > Constants.MAX_THEORETICAL_COMPARE_VALUE) {
			result = false;
		} else {
			// this is a temp variable to help determine what the letter / octave are
			double tempCompValue = compareVal;
					
			// Determine if this is a sharp or not, by seeing if there is a 0.5 modifier.
			if (tempCompValue % 1 == 0.5) {
				isSharp = true;
				tempCompValue -= 0.5;
			}
			// End result: a whole-number "temp" compare value.
			// Next, we'll shave off octaves 1 at a time, until we are left with a note position, which can be used to directly get the note letter.
			while (tempCompValue > 7) {
				tempCompValue -= 7;
			}
			note = NoteUtils.getNoteForPosition((int)tempCompValue);
			
			// Check if we have an impossible note, but since we were trying to build from a compareValue, we can't be sure whether to promote or demote
			// (we don't know if they were trying to make a C become a flat (a B), or a B become a sharp (a C)
			if ( (note.equalsIgnoreCase(Constants.NOTE_B) && isSharp) ||
				 (note.equalsIgnoreCase(Constants.NOTE_E) && isSharp) ) {
				
				// Since we are basing this off of a "compare value", we can't tell if it was meant to be a B sharp (and thus, a C), or a C flat (and thus, a B),
				// since both of those are invalid and would resolve to a compare value of "6.5".
				result = false;
			}
		}

		return result;
	}
}
