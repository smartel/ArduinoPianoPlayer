package Utils;

public class NoteUtils {

	
	public NoteUtils() {
	}
	
	/**
	 * Generates a numeric value that represents the key's position on the piano, as well as making it intuitively comparable to other keys on the piano.
	 * Each white note is a whole value step (1), and half values are half-steps (sharps / flats)
	 * To show how it is intuitive - this means that "C" would be 2 steps away from "E" (C to D, then D to E, or alternatively, E to D, and then D to C)
	 *
	 * There is one special case: a Rest note is treated as having a compare value of 0, as it has no octave, no note letter, and can't be sharp or flat.
	 * Since no key is struck for a rest, there is no compare value that could be generated for it. Do not attempt to call generateCompareValue for a rest.
	 * The constant compare value used for rest notes can be found in Constants.java # REST_COMP_VALUE
	 *
	 * To generate this number, 2 values are added together:
	 * 	Value 1: generated by mapping notes to their integer position within an octave, and adding or subtracting 0.5 for sharps / flats.
	 *  	A=1,B=2,...,G=7    A flat = 0.5, A sharp = 1.5 == B flat = 1.5 ...  G flat = 6.5, G sharp = 7.5
	 * 	Value 2: generated via ((n-1)*7), where n is the octave the key is in. 1 is subtracted from n, so that the first value, "A" of octave 1, returns 1, "B" of octave 1 returns 2, and so on.
	 * By adding values 1 and 2 together, we can compare notes on a keyboard.
	 * For example, a 2nd octave "D" generates the value: 4 + (7*1) = 11
	 *              a 3rd octave "A" generates the value: 1 + (7*2) = 15
	 * If these 2 values are compared together,
	 *  it is shown that a 2nd octave "D" is a lower note than a 3rd octave "A",
	 *  and it is possible to get the key distance between them with simple subtraction.
	 *		15 - 11 == absolute value of 11 - 15 = distance of 4 keys (it takes 4 moves to get from that D key to that A key, or from that A key to get to that D key)
	 * Lastly, an A-flat on one octave can be shown to be equivalent to a G-sharp on the previous octave.
	 * 	 A-flat on octave 3 = 1(for A) - 0.5(for flat) + ((3-1)*7) = 0.5 + 14 = 14.5
	 *   G-sharp on octave 2 = 7(for G) + 0.5(for sharp) + ((2-1)*7) = 7.5 + 7 = 14.5
	 */
	public static double generateCompareValue(String note, int octave, boolean isSharp, boolean isFlat) {

		double value = 0;
		
		// Note: there is some mild duplicated error checking in here, but within reason - NoteUtils only cares about ensuring it is creating a valid compareValue.
		// Thus, it will ensure the octave is not non-zero / non-negative for non-rest notes, much like the MusicNote's initializer should've already checked.
		// HOWEVER, it will not check if the note exists on your piano itself - its only responsibility is creating a valid compareValue, regardless of whether it exists on your piano.

		// individual note lookup
		
		if (note.equalsIgnoreCase(Constants.A_NOTE)) {
			value += Constants.A_POS;
		} else if (note.equalsIgnoreCase(Constants.B_NOTE)) {
			value += Constants.B_POS;
		} else if (note.equalsIgnoreCase(Constants.C_NOTE)) {
			value += Constants.C_POS;
		} else if (note.equalsIgnoreCase(Constants.D_NOTE)) {
			value += Constants.D_POS;
		} else if (note.equalsIgnoreCase(Constants.E_NOTE)) {
			value += Constants.E_POS;
		} else if (note.equalsIgnoreCase(Constants.F_NOTE)) {
			value += Constants.F_POS;
		} else if (note.equalsIgnoreCase(Constants.G_NOTE)) {
			value += Constants.G_POS;
		} else if (note.equalsIgnoreCase(Constants.REST_NOTE)) {
			// We have a hardcoded value for rest notes - a compare value of 0.
			value = Constants.REST_COMP_VALUE;
		} else {
			System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - unrecognized note value passed in.\r\nnote: " + note);
			value = -1;
		}
		
		// note modifications via half-steps
		// but if the value is already 0 (a rest note) or -1 (already failed), don't bother checking and potentially overwriting the current value.
		if (isSharp && isFlat) {
			// although, if it is a rest note, we only need to warn
			if (note.equalsIgnoreCase(Constants.REST_NOTE)) {
				System.out.println("NoteUtils#generateCompareValue - warning - isSharp and isFlat both set to true, but on a rest note, so initialization will continue.\r\nConfirmation - isSharp: " + isSharp + ", isFlat: " + isFlat + ", note: " + note);
			} else {
				System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - isSharp and isFlat both set to true.\r\nConfirmation - isSharp: " + isSharp + ", isFlat: " + isFlat);
				value = -1;
			}
		} else if (isSharp && value > 0) {
			value += Constants.SHARP_CHANGE;
		} else if (isFlat && value > 0) {
			value += Constants.FLAT_CHANGE; // adding a negative to the value to reduce it
		}
		
		// octave adjustment - only needs to confirm the octave is non-zero / non-negative. it can accurately create a compareValue for an octave no matter how high it is.
		if (octave <= 0 && (!note.equalsIgnoreCase(Constants.REST_NOTE))) {
			System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - invalid octave value (0 or negative).\r\noctave: " + octave);
			return -1;
		}
		// Ensure the octave is zero if it is a rest note, but if it isn't, we only need to provide a warning, and can keep initializing
		if (octave != 0 && (note.equalsIgnoreCase(Constants.REST_NOTE))) {
			System.out.println("NoteUtils#generateCompareValue - warning - non-zero octave value provided for a rest note. Octave value ignored.\r\noctave: " + octave);
		}
		
		if (value > 0) {
			value += ((octave - 1) * Constants.OCTAVE_LENGTH);
		}
		
		return value;
	}
	
	
	
	
}
