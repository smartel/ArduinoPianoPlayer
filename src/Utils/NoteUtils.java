package Utils;

import DataObjs.PianoProperties;

public class NoteUtils {

	
	public NoteUtils() {
	}
	
	/**
	 * Generates a numeric value that represents the key's position on the piano, as well as making it intuitively comparable to other keys on the piano.
	 * Each white note is a whole value step (1), and half values are half-steps (sharps / flats)
	 * To show how it is intuitive - this means that "C" would be 2 steps away from "E" (C to D, then D to E, or alternatively, E to D, and then D to C)
	 *
	 * There is one special case: a Rest note is treated as having a compare value of 0, as it has no octave, no note letter, and can't be sharp or flat.
	 * Since no key is struck for a rest, there is no compare value that could be generated for it. Do not attempt to call generateCompareValue for a rest.
	 * The constant compare value used for rest notes can be found in Constants.java # REST_COMP_VALUE
	 *
	 * To generate this number, 2 values are added together:
	 * 	Value 1: generated by mapping notes to their integer position within an octave, and adding or subtracting 0.5 for sharps / flats.
	 *  	C=1,D=2,...,A=7    C flat = 0.5, C sharp = 1.5 == D flat = 1.5 ...  B flat = 6.5, B sharp = well ok bad example, that'd be a C, there is no B sharp.
	 * 	Value 2: generated via (n*7), where n is the octave the key is in. Remember that octaves start at 0, so the first value, "C" of octave 0, returns 1, "D" of octave 0 returns 2, and so on.
	 * By adding values 1 and 2 together, we can compare notes on a keyboard.
	 * For example, a 2nd octave "E" generates the value: 3 + (7*2) = 17
	 *              a 1st octave "A" generates the value: 6 + (7*1) = 13
	 * If these 2 values are compared together,
	 *  it is shown that a 1st octave "A" is a lower note than a 2nd octave "E",
	 *  and it is possible to get the key distance between them with simple subtraction.
	 *		17 - 13 == absolute value of 13 - 17 = distance of 4 keys (it takes 4 moves to get from that E key to that A key, or from that A key to get to that E key)
	 * Lastly, we can technically show that a C-flat on one octave is equivalent to a B-sharp on the previous octave.
	 * 	 C-flat on octave 3 = 1(for C) - 0.5(for flat) + (3*7) = 1 - 0.5 + 21 = 21.5
	 *   B-sharp on octave 2 = 7(for B) + 0.5(for sharp) + (2*7) = 7.0 + 0.5 + 14 = 21.5 (however, B-sharp doesn't exist, so this would be promoted to a C)
	 */
	public static double generateCompareValue(String note, int octave, boolean isSharp, boolean isFlat) {

		double value = 0;
		
		// Note: there is some mild duplicated error checking in here, but within reason - NoteUtils only cares about ensuring it is creating a valid compareValue.
		// Thus, it will ensure the octave is not non-zero / non-negative for non-rest notes, much like the MusicNote's initializer should've already checked.
		// HOWEVER, it will not check if the note exists on your piano itself - its only responsibility is creating a valid compareValue, regardless of whether it exists on your piano.

		// individual note lookup
		
		if (note.equalsIgnoreCase(Constants.NOTE_C)) {
			value += Constants.C_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_D)) {
			value += Constants.D_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_E)) {
			value += Constants.E_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_F)) {
			value += Constants.F_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_G)) {
			value += Constants.G_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_A)) {
			value += Constants.A_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_B)) {
			value += Constants.B_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_REST)) {
			// We have a hardcoded value for rest notes - a compare value of 0.
			value = Constants.REST_COMP_VALUE;
		} else {
			System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - unrecognized note value passed in.\r\nnote: " + note);
			value = -1;
		}
		
		// note modifications via half-steps
		// but if the value is already 0 (a rest note) or -1 (already failed), don't bother checking and potentially overwriting the current value.
		if (isSharp && isFlat) {
			// although, if it is a rest note, we only need to warn
			if (note.equalsIgnoreCase(Constants.NOTE_REST)) {
				System.out.println("NoteUtils#generateCompareValue - warning - isSharp and isFlat both set to true, but on a rest note, so initialization will continue.\r\nConfirmation - isSharp: " + isSharp + ", isFlat: " + isFlat + ", note: " + note);
			} else {
				System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - isSharp and isFlat both set to true.\r\nConfirmation - isSharp: " + isSharp + ", isFlat: " + isFlat);
				value = -1;
			}
		} else if (isSharp && value > 0) {
			value += Constants.SHARP_CHANGE;
		} else if (isFlat && value > 0) {
			value += Constants.FLAT_CHANGE; // adding a negative to the value to reduce it
		}
		
		// octave adjustment - only needs to confirm the octave is non-zero / non-negative. it can accurately create a compareValue for an octave no matter how high it is.
		if (octave < Constants.MIN_PIANO_OCTAVE && (!note.equalsIgnoreCase(Constants.NOTE_REST))) {
			System.out.println("NoteUtils#generateCompareValue - failed to generate compare value - invalid octave value (0 or negative).\r\noctave: " + octave);
			return -1;
		}
		// Ensure the octave is zero if it is a rest note, but if it isn't, we only need to provide a warning, and can keep initializing
		if (octave != Constants.REST_OCTAVE_VALUE && (note.equalsIgnoreCase(Constants.NOTE_REST))) {
			System.out.println("NoteUtils#generateCompareValue - warning - non-zero octave value provided for a rest note. Octave value ignored.\r\noctave: " + octave);
		}
		
		if (value > 0) {
			value += (octave * Constants.OCTAVE_LENGTH);
		}
		
		return value;
	}
	
	/**
	 * Helper method that, when given a natural note (such as C, D, E, F, G, A or B), will return its position within an octave (ie, C=1, D=2, ... A=7)
	 * This is basically the opposite of getNoteForPosition.
	 * @return integer representing the note's position within an octave. if a position can't be determined, -1 is returned instead.
	 */
	public static int getPositionForNote(String note) {
		int value = -1;
		
		if (note.equalsIgnoreCase(Constants.NOTE_C)) {
			value = (int)Constants.C_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_D)) {
			value = (int)Constants.D_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_E)) {
			value = (int)Constants.E_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_F)) {
			value = (int)Constants.F_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_G)) {
			value = (int)Constants.G_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_A)) {
			value = (int)Constants.A_POS;
		} else if (note.equalsIgnoreCase(Constants.NOTE_B)) {
			value = (int)Constants.B_POS;
		} else {
			System.out.println("NoteUtils#getPositionForNote - error - invalid note value passed in, position can't be determined. note: " + note);
		}
		
		return value;
	}
	
	/**
	 * Helper method that, when given a position within an octave (such as 1 (1st note), 2 (2nd note), 3 (3rd note), ... 7 (7th note)),
	 * will return the note letter for this position (ie, 1=C, 2=D,, ... 7=A)
	 * This is basically the opposite of getPositionForNote.
	 * @return String letter representing the note letter. If a value can't be determined, an empty String will be returned.
	 */
	public static String getNoteForPosition(int position) {
		String value = "";
		
		if (position == 1) {
			value = Constants.NOTE_C;
		} else if (position == 2) {
			value = Constants.NOTE_D;
		} else if (position == 3) {
			value = Constants.NOTE_E;
		} else if (position == 4) {
			value = Constants.NOTE_F;
		} else if (position == 5) {
			value = Constants.NOTE_G;
		} else if (position == 6) {
			value = Constants.NOTE_A;
		} else if (position == 7) {
			value = Constants.NOTE_B;
		} else {
			System.out.println("NoteUtils#getNoteForPosition - error - invalid position value passed in, note letter can't be determined. position: " + position);
		}
		
		return value;
	}
	
	/**
	 * Given the compareValue for a specific note, as well as which piano voice / instrument to use,
	 * this will returns the uri of the appropriate .wav file to play the note (for use with the Feigner)
	 * 
	 * It should be noted, that the sounds played are simple .wav files, and their lengths are not extended or shortened by the note's duration,
	 * nor are they interruptable. You can kind of imagine the gui is... playing pizzicato. Quick little bursts for each note.
	 * When the arduino is in action, it will make use of the duration fields to know how long to extend a "finger" for on a note, so it will be used there.
	 * 
	 * @param compareValue the piano key to find the sound file for
	 * @param voice the instrument or "voice" (ie grand (piano), orgel, harpsichord, ...) to play the note with. See Constants.java for a list of implemented voices.
	 * @return uri of the .wav file containing that piano key's sound
	 */
	public static String getSoundWavForNote(double compareValue, String voice, PianoProperties properties) {
		String uri = "";
		boolean valid = true;
		double compMin = Double.parseDouble(properties.getSetting(Constants.SETTINGS_MIN_COMP_VALUE));
		double compMax = Double.parseDouble(properties.getSetting(Constants.SETTINGS_MAX_COMP_VALUE));
		
		if (!voice.equalsIgnoreCase(Constants.VOICE_ORGEL) && !voice.equalsIgnoreCase(Constants.VOICE_GRAND)) {
			System.out.println("NoteUrils#getSoundWavForNote - error - invalid voice supplied: " + voice);
			valid = false;
		}
		
		// compareValue range checking
		if (compareValue == Constants.REST_COMP_VALUE) {
			System.out.println("NoteUrils#getSoundWavForNote - error - invalid compare value given: " + Constants.REST_COMP_VALUE + ". Was this accidentally called for a Rest note? Confirmation - compareValue: " + compareValue);
		}
		// use piano properties to get min / max compare value for range checking.
		if ( (compareValue < compMin) ||
			 (compareValue > compMax) ) {
			System.out.println("NoteUrils#getSoundWavForNote - error - invalid compare value supplied: " + compareValue + ". Maximum range via piano properties was between: " + compMin + " and " + compMax + ".");
		}
		
		
		if (valid && voice.equalsIgnoreCase(Constants.VOICE_ORGEL)) {
			uri = "orgel/" + compareValue + ".wav";
		} else if (valid && voice.equalsIgnoreCase(Constants.VOICE_GRAND)) {
			uri = "grand/" + compareValue + ".wav";
		}
		
		return uri;
	}
	
	/**
	 * Given a compareValue, this will determine the next immediately after it, whether it is a whole note skip or just a sharp
	 * (so, it determines if 0.5 or if 1.0 needs to be added to the current compare value), and then returns it
	 * @param compareVal the compareValue of the current note, to generate the next note's value from
	 * @return the compareValue of the note immediately after the supplied note, or -1 if an invalid compareVal was supplied
	 */
	public static double getNextNoteCV(double compareVal) {
		double nextCompVal = -1;
		
		// since generating the compare value simply follows a pattern of seeing what letter note we're on and what the next letter note is,
		// we don't really need to do bounds checking on the input value other than making sure it isn't negative / 0
		if (compareVal <= Constants.REST_COMP_VALUE) {
			System.out.println("NoteUtils#getNextNoteCV - error - invalid compare value supplied to generate the next note from. Supplied compareVal: " + compareVal);
		} else {
			if (compareVal % 1 == 0.5) { // if we are on a sharp, then we know we just need to add 0.5 to get to the next note
				nextCompVal = compareVal + 0.5;
			} else {
				// we know we are not on a sharp/flat, so we're on A,B,C,D,E,F,G. B and E do not have sharps.
				// narrow it down to one octave, so we solely had the "Note Position within an octave", ie, 1=A, 2=B, ..., 7=G
				int temp = (int)compareVal;
				while (temp > 7) {
					temp -= 7;
				}
				if (temp == Constants.B_POS || temp == Constants.E_POS) { // if B or E, we add one to the given compareValue and return it, since there is no sharp on these two notes
					nextCompVal = compareVal + 1;
				} else { // otherwise, it has a sharp
					nextCompVal = compareVal + 0.5;
				}
			}
		}
		
		return nextCompVal;
	}
	
}
